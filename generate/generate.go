package generate

import (
	"context"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-fish/gojson/log"
	gimports "golang.org/x/tools/imports"
)

// Generator defines the generator to generate gojson code
type Generator interface {
	Generate(name, path string, imports map[string]string, objects ...Object) error
}

type generator struct {
	Unsafe        bool
	EscapeHTML    bool
	EscapeUnicode bool
	Output        string
}

// NewGenerator returns the instance of Generator
func NewGenerator(
	unsafe bool,
	escapeHTML bool,
	escapeUnicode bool,
	output string,
) Generator {
	return &generator{unsafe, escapeHTML, escapeUnicode, output}
}

// Generate generate gojson code for one package
func (g *generator) Generate(
	name string,
	path string,
	imports map[string]string,
	objects ...Object,
) (err error) {
	log.Infof("Generating code for path %s", path)
	defer log.ErrorOrInfof(
		err,
		func() { log.Infof("Successed to generate code for path %s", path) },
		func() { log.Errorf("Failed to generate code for path %s, error: %s", path, err) },
	)

	w := acquireWriter()
	defer releaseWriter(w)

	w.line("// ************************************************************")
	w.line("// DO NOT EDIT.")
	w.line("// THIS FILE IS AUTO-GENERATED BY go-fish/gojson.")
	w.line("// ************************************************************")
	w.line("")
	w.line("package %s", name)
	w.line("import(")

	// add initialize imports
	w.line("%s %q", "backend", "github.com/go-fish/gojson/backend")

	for key, value := range imports {
		if key == value {
			w.line("%s", key)
			continue
		}

		w.line("%s %s", value, key)
	}

	w.line(")")

	// generate object
	for _, obj := range objects {
		if err = g.generate(
			ContextWithGenerateType(context.TODO(), obj.Meta().GetGenerateType()),
			obj,
			w,
		); err != nil {
			return err
		}
	}

	// write to generated file
	filename := filepath.Join(path, g.Output)
	os.Remove(filename)

	data, err := gimports.Process(filename, w.bytes(), nil)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, data, 0600)
}

func (g *generator) generate(ctx context.Context, obj Object, w writer) (err error) {
	switch GenerateTypeInContext(ctx) {
	case BothGenerateType:
		if err := g.genDecodeCode(ctx, obj, w); err != nil {
			return err
		}

		return g.genEncodeCode(ctx, obj, w)

	case EncodeGenerateType:
		return g.genEncodeCode(ctx, obj, w)

	case DecodeGenerateType:
		return g.genDecodeCode(ctx, obj, w)

	default:
		return nil
	}
}

func (g *generator) genDecodeCode(ctx context.Context, obj Object, w writer) error {
	w.line("func(%s *%s) UnmarshalJSON(data []byte) error {", shortName(obj), obj.Meta().GetName())
	w.line("dec := backend.NewDecoder(data, %s)", g.decodeOptions())
	w.line("defer backend.ReleaseDecoder(dec)")
	w.line("")

	ctx = ContextWithArgvName(ctx, shortName(obj))
	if err := obj.GetUnderlying().GenerateDecode(ctx, w); err != nil {
		return err
	}

	w.line("")
	w.line("return nil")
	w.line("}")
	w.line("")
	return nil
}

func (g *generator) decodeOptions() string {
	var opts []string

	if g.Unsafe {
		opts = append(opts, "backend.WithUnsafe()")
	}

	return strings.Join(opts, ",")
}

func (g *generator) genEncodeCode(ctx context.Context, obj Object, w writer) error {
	w.line("func(%s *%s) MarshalJSON() ([]byte, error) {", shortName(obj), obj.Meta().GetName())
	w.line("enc := backend.NewEncoder(%s)", g.encodeOptions())
	w.line("defer backend.ReleaseEncoder(enc)")
	w.line("")

	ctx = ContextWithArgvName(ctx, shortName(obj))
	if err := obj.GetUnderlying().GenerateEncode(ctx, w); err != nil {
		return err
	}

	w.line("return enc.Bytes(), nil")
	w.line("}")
	w.line("")
	return nil
}

func (g *generator) encodeOptions() string {
	var opts []string

	if g.EscapeHTML {
		opts = append(opts, "backend.WithEscapeHTML()")
	}

	if g.EscapeUnicode {
		opts = append(opts, "backend.WithEscapeUnicode()")
	}

	return strings.Join(opts, ",")
}
